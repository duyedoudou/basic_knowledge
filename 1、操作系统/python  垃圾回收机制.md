## Python的垃圾回收机制

 DY 2019.7.20



### 引用计数

Python中每个东西都是对象，ob_refcnt是对象的引用计数，当有新的变量引用对象时，ob_refcnt就会增加，当引用变量被删除时，ob_refcnt就会减少。

引用计数的**优点**：简单、实时。**缺点**：两个变量互相引用时，内存将永远无法被回收。



### 分代回收

思想：对象存在的时间越长，越不可能是垃圾。

- 将对象的生存时间分为3代，0-2。初始为第0代

- 0代经过一次垃圾回收依然存在的对象，放入第1代；1代中经过一次垃圾回收依然存在的对象放入第2代。

- 不同代的回收频次不一样。引用大于删除的量，进行0代回收，0代回收n次后，进行一次1代回收……



### 标记回收

  ![mark-sweepg](https://foofish.net/images/mark-sweep.svg)

  

我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被回收。  





### 孤立的引用环

```python
lt1 = [1, 2, 3]
lt2 = [lt1]

lt1.append(lt2)

del lt1
del lt2
```

上边代码块中创建了两个列表对象lt1, lt2 。这两个列表对象相互引用，形成孤立的引用环。当删除lt1, lt2的时候，以上两个列表对象在程序中将无法被调用，但是其实际的引用计数并不为0，不会被垃圾回收。

为了回收这样的引用环，python复制每一个对象的引用计数（lt1:1, lt2:1）。然后，python遍历所有的引用环涉及到的对象，该处仅有lt1 和lt2 ，当遍历到lt1时，**由于lt1引用了lt2, 故将lt2的引用计数减1**。同理，当遍历到lt2的时候将lt1的引用计数减1，结果他们的值都为0，最后将不为0的对象保留，为0 的对象进行垃圾回收。

  











