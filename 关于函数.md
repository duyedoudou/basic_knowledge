#### 函数的\_\_doc\_\_属性

打印三引号里的内容

```python 
def func():
    '''这是个函数的例子'''
    return 42
print(func.__doc__)
```

```
这是个函数的例子
```

#### 关于匿名函数：

除了作为参数传给高阶函数（如map）之外，Python很少使用lambda函数。

类中如果定义了\_\_call\_\_方法，那么他的实例可以作为函数调用。

#### callable()函数：用来判断对象是否可调用的安全的方法

```python 
[callable(i) for i in (abs,str,13)]   # 数字不可调用
```

```
[True, True, False]
```

#### 类中定义\_\_call\_\_方法，实现将类的实例化作为函数使用

```Python
import random
class Bingocage:
    def __init__(self,item):
        self._item = list(item)  # 构建副本
        random.shuffle(self._item)
        
    def pick(self):
        return self._item
    
    def __call__(self):      # 定义__call__
        return self.pick()
    

bingo = Bingocage([1,2,3,4])
print(bingo.pick())           # 正常操作
print(bingo())                # 作为函数调用，即可以运用()运算符

print(callable(bingo))        # 判断是否可调用
```

```
[4, 2, 3, 1]
[4, 2, 3, 1]
True
```

#### 函数注解：

注解不会做任何处理，只是存储在函数的__annotations\_\_属性中。字典形式。

也就是说，注解对Python解释器没有任何意义。

```python 
def clip(text,max_len=80):

# 对比
# 各个参数在：之后增加注解表达式，
# 如果参数有默认值，注解放在参数名和=之间
# 注解返回值，在最后的 ： 前添加  ->
def clip(text:str,max_len:'int>0'=80) -> str:
 
```

#### operator模块：

operator为多个运算符提供了对应的函数。

mul

```python 
from functools import reduce
from operator import mul            # 两数相乘,省的自己定义函数了

def func(n):
    return reduce(mul,range(1,n+1))

print(func(3))
```

```
6
```

itemgetter

```python
from operator import itemgetter

lis = [('we','jp',33),('re','in',21),('ds','us',14),('cv','br',55)]
for i in sorted(lis,key=itemgetter(1)):   # 作用和lambda i:i[1] 一样，返回索引位1的元素
    print(i)
```

```
('cv', 'br', 55)
('re', 'in', 21)
('we', 'jp', 33)
('ds', 'us', 14)
```

attrgettr

(略)

#### functools模块：

partial冻结参数，即将原来的函数的一部分参数先给固定住

```python 
from operator import mul
from functools import partial

a = partial(mul,3)             # 把mul函数的第一个参数固定为3
print(a(8))

```

```
24
```

```python 
# 接着上边的
list(map(a,range(5)))
```

```
[0, 3, 6, 9, 12]
```

#### 重新认识装饰器:

```python 
@decorate 
def target():
    print('hello')
    
# 上述代码的效果和下边的一样

def target():
    print('hello')
target = decorate(target)
```

装饰器有这么两个特点：1、把被装饰的函数替换成其他函数。2、装饰器在加载模块时立即执行。

关于第二点，看个例子：

```Python
registry = []
def register(func):                    # 定义装饰器
    print('我是装饰器，我在搞:%s'%func)
    registry.append(func)
    return func

@register                              # 装饰f1
def f1():
    print('我是f1')
  
@register                              # 装饰f2
def f2():
    print('我是f2')

def f3():                              # 没有装饰f3
    print('我是f3')
    
print('registry里有这些：',registry)
f1()
f2()
f3()

```

```
我是装饰器，我在搞:<function f1 at 0x1054fc510>
我是装饰器，我在搞:<function f2 at 0x1054fc2f0>
registry里有这些： [<function f1 at 0x1054fc510>, <function f2 at 0x1054fc2f0>]
我是f1
我是f2
我是f3
```

这个例子主要强调在加载模块时候立即执行，被装饰的函数（f1,f2,f3）只在明确调用时候才运行。

此处显示了`导入时`和`运行时`之间的区别。

#### 变量作用域：

先看个例子，吃上一惊。回头再解释。

```Python
b = 8
def f2(a):
    print(a)
    print(b)
    b = 9      # b在此处定义
f2(6)
```

```
6
UnboundLocalError: local variable 'b' referenced before assignment
```

报错看见没，上边有全局变量b啊，为啥还报错。（再此先说个没写的，如果b=9注释掉，结果是6  8）。

下面解释报错的原因：

> Python在编译函数的定义体时候，他判断b是局部变量，生成的`字节码`证实了这种判断，python会尝试从本地环境获取b,但是打印b时候b还没绑定值。所以就报错了。
>
> Python不要求声明局部变量，但是假定在函数体中的变量是局部变量。

LEGB:



#### 闭包：

```python 
def func():
    liss = []             
    def f(a):
        liss.append(a)           # 在函数f中，liss是自由变量，指没在本地作用域中绑定的变量
        total = sum(liss)
        return total/len(liss)
    return f

aa = func()
print(aa(2))                     # 调用函数func()
print(aa(8))
```

```
2.0
5.0
```

注意，在调用函数aa(2)时候，func()函数就已经返回了，他的本地作用域也拜拜了。

> 但是闭包会保留定义函数时候存在的自由变量的绑定，这样的话，在调用函数时，虽然func()的作用域拜拜了，但是仍然能使用那些绑定。

下边来看一个错误的例子：

```python 
def func():
    count = 0
    total = 0
    def f(a):
        count += 1
        total += a
        return total/count
    
aa = func()
aa(2)
```

```
报错:UnboundLocalError: local variable 'count' referenced before assignment
```

原因：首先count是不可变类型。count += 1的操作相当于在f的函数体中对count赋值了，这就隐式的把count变成了局部变量，那就不是自由变量了，就不能保存在闭包中了。total也是一样的。

##### 那怎么办呢？看注释。

```Python
def func():
    count = 0
    total = 0
    def f(a):
        nonlocal count,total        # 使用nonlocal
        count += 1
        total += a
        return total/count
    return f
    
aa = func()
print(aa(2))
print(aa(8))
```

```
2.0
5.0
```

#### functools.lru_cache装饰器：

```python 
%%time
import functools
@functools.lru_cache()        # 有一对括号，原因是lru_cache可接受配置参数
def fib(n):
    if n<2:
        return n
    return fib(n-2) + fib(n-1)

print(fib(30))
```

```
832040
CPU times: user 266 µs, sys: 110 µs, total: 376 µs
Wall time: 328 µs
```

对比：

```Python
%%time
# import functools
# @functools.lru_cache()        # 有一对括号，原因是lru_cache可接受配置参数
def fib(n):
    if n<2:
        return n
    return fib(n-2) + fib(n-1)

print(fib(30))
```

```
832040
CPU times: user 572 ms, sys: 14.2 ms, total: 586 ms
Wall time: 781 ms
```

看见时间差异没？使用functools.lru_cache() 装饰器时，性能明显改善，因为他实现了缓存技术。

那现在具体看下他的参数配置：

`functools.lru_cache(maxsize=128,typed=False)`

maxsize指存储多少个调用结果，存满后，旧的会被扔掉，maxsize应设为2的幂。

typed如果设为True，通常会把1和1.0区分开。

另外，lru_cache使用字典存储，字典的键是根据电泳时传入的参数创建，因此，被装饰的函数的参数都必须是可以散列的。

#### functools.singledispatch装饰器：

抽空看帖子

