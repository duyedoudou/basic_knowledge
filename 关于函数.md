#### 函数的\_\_doc\_\_属性

打印三引号里的内容

```python 
def func():
    '''这是个函数的例子'''
    return 42
print(func.__doc__)
```

```
这是个函数的例子
```

#### 关于匿名函数：

除了作为参数传给高阶函数（如map）之外，Python很少使用lambda函数。

类中如果定义了\_\_call\_\_方法，那么他的实例可以作为函数调用。

#### callable()函数：用来判断对象是否可调用的安全的方法

```python 
[callable(i) for i in (abs,str,13)]   # 数字不可调用
```

```
[True, True, False]
```

#### 类中定义\_\_call\_\_方法，实现将类的实例化作为函数使用

```Python
import random
class Bingocage:
    def __init__(self,item):
        self._item = list(item)  # 构建副本
        random.shuffle(self._item)
        
    def pick(self):
        return self._item
    
    def __call__(self):      # 定义__call__
        return self.pick()
    

bingo = Bingocage([1,2,3,4])
print(bingo.pick())           # 正常操作
print(bingo())                # 作为函数调用，即可以运用()运算符

print(callable(bingo))        # 判断是否可调用
```

```
[4, 2, 3, 1]
[4, 2, 3, 1]
True
```

#### 函数注解：

注解不会做任何处理，只是存储在函数的__annotations\_\_属性中。字典形式。

也就是说，注解对Python解释器没有任何意义。

```python 
def clip(text,max_len=80):

# 对比
# 各个参数在：之后增加注解表达式，
# 如果参数有默认值，注解放在参数名和=之间
# 注解返回值，在最后的 ： 前添加  ->
def clip(text:str,max_len:'int>0'=80) -> str:
 
```

#### operator模块：

operator为多个运算符提供了对应的函数。

mul

```python 
from functools import reduce
from operator import mul            # 两数相乘,省的自己定义函数了

def func(n):
    return reduce(mul,range(1,n+1))

print(func(3))
```

```
6
```

itemgetter

```python
from operator import itemgetter

lis = [('we','jp',33),('re','in',21),('ds','us',14),('cv','br',55)]
for i in sorted(lis,key=itemgetter(1)):   # 作用和lambda i:i[1] 一样，返回索引位1的元素
    print(i)
```

```
('cv', 'br', 55)
('re', 'in', 21)
('we', 'jp', 33)
('ds', 'us', 14)
```

attrgettr

(略)

#### functools模块：

partial冻结参数，即将原来的函数的一部分参数先给固定住

```python 
from operator import mul
from functools import partial

a = partial(mul,3)             # 把mul函数的第一个参数固定为3
print(a(8))

```

```
24
```

```python 
# 接着上边的
list(map(a,range(5)))
```

```
[0, 3, 6, 9, 12]
```

