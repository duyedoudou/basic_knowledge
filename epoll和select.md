### epoll和select

------

DY  2019.7.20

##### 什么是阻塞：

阻塞是进程调度的关键一环，指的是进程在`等待`某事件（如接收到网络数据）发生之前的等待状态，recv、select和epoll都是阻塞方法。

—————————>

##### 引子：

不停的把所有流从头到尾问一遍，又从头开始,这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。

为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。

 于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。

但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。

`epoll`可以理解为`event poll`，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。

##### 生动的例子：

假设你在大学读书，住的宿舍楼有很多间房间，你的朋友要来找你。

`select版`宿管大妈就会带着你的朋友挨个房间去找，直到找到你为止。
而`epoll版`宿管大妈会先记下每位同学的房间号，你的朋友来时，只需告诉你的朋友你住在哪个房间即可，不用亲自带着你的朋友满大楼找人。

如果来了10000个人，都要找自己住这栋楼的同学时，select版和epoll版宿管大妈，谁的效率更高，不言自明。
同理在高并发服务器中，轮询I/O是最耗时间的操作之一，select和epoll的性能谁的性能更高，同样十分明了。

select的调用复杂度是线性的，即O(n)。

一个保姆照看一群孩子，如果把孩子是否需要尿尿比作网络IO事件，`select的作用`就好比这个保姆挨个询问每个孩子：你要尿尿吗？<u>如果孩子回答是，保姆则把孩子拎出来放到另外一个地方</u>。当所有孩子询问完之后，保姆领着这些要尿尿的孩子去上厕所（处理网络IO事件）。

在`epoll机制`下，保姆不再需要挨个的询问每个孩子是否需要尿尿。取而代之的是，每个孩子如果自己需要尿尿的时候，自己主动的站到事先约定好的地方，而保姆的职责就是<u>查看事先约定好的地方是否有孩子</u>。如果有小孩，则领着孩子去上厕所（网络事件处理）。

因此，epoll的这种机制，能够高效的处理成千上万的并发连接，而且性能不会随着连接数增加而下降。

##### 比较：

![img](https://img.mukewang.com/5bd6dbfb0001631210000428.jpg)

